# -*- coding: utf-8 -*-
"""Copy of GCC-Data-structures-types_student_version.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IxIZtwXPtL8D5WuIsbD2q5kuR0Ol6SIg

<div align="center" style=" font-size: 80%; text-align: center; margin: 0 auto">
<img src="https://raw.githubusercontent.com/Explore-AI/Pictures/master/Python-Notebook-Banners/Code_challenge.png"  style="display: block; margin-left: auto; margin-right: auto;";/>
</div>

# Graded code challenge: Data structures and types
© ExploreAI Academy

⚠️ **Note that this code challenge is graded and will contribute to your overall marks for this module.**

### Instructions

- **Do not add or remove cells in this notebook. Do not edit or remove the `### START FUNCTION` or `### END FUNCTION` comments. Do not add any code outside of the functions you are required to edit. Doing any of this will lead to a mark of 0%!**

- Answer the questions according to the specifications provided.

- Use the given cell in each question to see if your function matches the expected outputs.

- Do not hard-code answers to the questions.

- The use of StackOverflow, Google, and other online tools is permitted. However, copying a fellow student's code is not permissible and is considered a breach of the honour code. Doing this will result in a mark of 0%.

## Introduction




I hope you are buzzing with the satisfaction of having completed the water infrastructure project in Maji Ndogo. Your brilliant work has not only improved lives but also opened doors to new possibilities. Now, we have another thrilling challenge ahead of us, and I believe it's right up our alley!

We're stepping into a domain where technology meets agriculture. Maji Ndogo, with your help, is looking to revolutionise its farming industry through automation, using the power of data science and AI. The long-term goal? Fully autonomous farming equipment that can intelligently manage and optimise agricultural processes. Exciting, isn't it?

<div align="center" style="font-size: 80%; text-align: center; margin: 0 auto">
    <img src="https://raw.githubusercontent.com/Explore-AI/Pictures/457505ff64842b573a30ca654e645854e447c406/alx_ds_python/Code_challenges/Sanaa_Ayo_avatar.png"
         style="display: block; margin-left: auto; margin-right: auto; width: 50%; height: auto;"/>
</div>

However, before we dive into the world of AI-driven tractors and smart irrigation systems, we need to lay the groundwork. Our first step is to tackle how we can programmatically represent this problem. Think of it as creating a 'Digital Twin' of the farming ecosystem in Maji Ndogo.

This Digital Twin will be our sandbox, where we can experiment, analyse, and fine-tune our approaches before implementing them in the real world. But how do we build such a model? How do we ensure it accurately reflects the complexities of a real farm?

Here's where our Python skills come into play. We’ll start by representing various elements of a farm – like fields, crops, and farming equipment. We will have to encapsulate operations like planting, watering, and harvesting.

Of course, this is just scratching the surface. We'll encounter and solve various challenges along the way, using more advanced concepts and techniques. But I'm confident that with your skills and enthusiasm, we'll make this project another success story.

Looking forward to embarking on this journey with you all. Let's turn the fields of Maji Ndogo into a beacon of technological advancement in agriculture!

## Challenge 1: Represent a tractor with a dictionary
In the world of digital farming, the first step is to bring our farm machinery into the digital realm. Let's start with the tractor, the workhorse of the farm. Digitising the tractor allows us to simulate and analyse its performance, maintenance needs, and usage patterns. This data-driven approach can lead to more efficient use of machinery, saving time and resources.

Why use a dictionary for this? In Python, a dictionary is a versatile and intuitive way to store and access data. It allows us to create a clear, structured representation of an object by mapping keys (property names) to values (property details). This is ideal for representing complex objects like tractors with multiple attributes.

### Task
Modify the function `create_tractor()` that uses the four parameters – `model`, `colour`, `horsepower`, and `fuel_capacity` – and use these to create and return a dictionary representing a tractor.

The dictionary should include the following keys:
`model`, `colour`, `horsepower`, and `fuel_capacity`. You can choose appropriate values for these keys based on what a typical tractor might have.

Answer:
"""

### START FUNCTION
def create_tractor(model, colour, horsepower, fuel_capacity):
    return {
        'model': model,
        'colour': colour,
        'horsepower': horsepower,
        'fuel_capacity': fuel_capacity
    }
### END FUNCTION

"""### Expected outputs

**Input 1:**

Expected output: `{'model': 'TX-1300', 'colour': 'Green', 'horsepower': 150, 'fuel_capacity': 60}`
"""

# input 1
create_tractor('TX-1300', 'Green', 150, 60)

"""<br>

**Input 2:**

Expected output: `{'model': 'RX-850', 'colour': 'Red', 'horsepower': 120, 'fuel_capacity': 45}`

"""

# input 2
create_tractor('RX-850', 'Red', 120, 45)

"""## Challenge 2: Represent a field

Now that we have our tractor in the digital realm, let's focus on another crucial aspect of the farm: the fields. A field is where the magic happens, where crops are grown and nurtured. In our Digital Twin of the farm, representing fields accurately is vital for planning, monitoring crop growth, and managing resources.

To digitally represent a field, we'll use a list of lists in Python. This structure is akin to a grid, where each sublist can represent a section or row of the farm field, allowing us to simulate and analyse different areas of the field individually.

When we have planted a row of crops in a field, we can represent it as a 1, while a 0 would represent a part of the field that is not planted. The unplanted field can be represented as a list of lists:
"""

# Unplanted field
unplanted_field = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0]
]

# Function to plant crops in a specific row
def plant_crops(field, row):
    if 0 <= row < len(field):
        field[row] = [1] * len(field[row])
    else:
        print("Invalid row number")

# Plant crops in the second row
plant_crops(unplanted_field, 1)

# Display the field
for row in unplanted_field:
    print(row)

"""This next variable would represent a field that is 3x3 in size, containing a row of plants at `index = 1`.

"""

planted_field = [
[0, 0, 0],
[1, 1, 1],
[0, 0, 0]
]

"""### Task

Given **any size field**, and **the index** of the row we would like to plant, convert the unplanted field into a planted one by specifying which row should be planted:

`plant_row(field, row_to_plant):` takes two parameters:

- `field`: a nested list representing a field.

- `row_to_plant`: an integer representing the **index** of the row to be planted.

Modify the function to **modify the specified row** in the field by setting all its elements to 1 (representing planting) and return the modified field. It should work regardless of the size of the field.

**Hint:** To create a list of 1s, multiply `[1]` with the length of the required list:
"""

[1] *10

"""Answer:"""

### START FUNCTION
def plant_row(field, row_to_plant):
    # Insert your code here
    return
### END FUNCTION

"""### Expected outputs

**Input 1:**

Expected output: `[[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]]`
"""

# input 1
plant_row([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], 1)

"""<br>

**Input 2:**

Expected output: `[[1, 1, 1, 1, 1], [0, 0, 0, 0, 0]]`

"""

plant_row([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], 0)

"""## Challenge 3: Represent all farm vehicles
In our Digital Twin farm, managing a diverse fleet of farm vehicles efficiently is key to optimising farm operations. Each vehicle in our fleet, such as tractors and harvesters, has specific attributes like model, colour, horsepower, and fuel capacity. By keeping a digital record of these vehicles, we can simulate various scenarios, like the impact of new vehicle acquisitions on our farming operations.

### Task

Modify `add_vehicle(vehicles, new_vehicle):` that adds a new vehicle to an existing list of vehicles. The function will take two parameters:

- `vehicles`: a list of dictionaries, where each dictionary represents a vehicle.

- `new_vehicle_params`: A list representing the new vehicle. It will contain values for `model`, `colour`, `horsepower`, and `fuel_capacity`, in that order.
"""

existing_vehicles = [
    {'model': 'TX-130', 'colour': 'Green', 'horsepower': 150, 'fuel_capacity': 60},
    {'model': 'RX-850', 'colour': 'Red', 'horsepower': 120, 'fuel_capacity': 45}
]

new_vehicle_params = ('ZX-500', 'Blue', 130, 55)

def add_vehicle(vehicles, new_vehicle_params):
    # Create a dictionary for the new vehicle
    new_vehicle = {
        'model': new_vehicle_params[0],
        'colour': new_vehicle_params[1],
        'horsepower': new_vehicle_params[2],
        'fuel_capacity': new_vehicle_params[3]
    }
    # Add the new vehicle to the list of existing vehicles
    vehicles.append(new_vehicle)
    return vehicles

# Example usage
existing_vehicles = [
    {'model': 'TX-130', 'colour': 'Green', 'horsepower': 150, 'fuel_capacity': 60},
    {'model': 'RX-850', 'colour': 'Red', 'horsepower': 120, 'fuel_capacity': 45}
]

new_vehicle_params = ('ZX-500', 'Blue', 130, 55)

updated_vehicles = add_vehicle(existing_vehicles, new_vehicle_params)
print(updated_vehicles)

"""### Expected outputs:

**Input 1:**

Expected output:

`[{'model': 'TX-130',
  'colour': 'Green',   'horsepower': 150,  'fuel_capacity': 60},
 {'model': 'RX-850', 'colour': 'Red', 'horsepower': 120, 'fuel_capacity': 45},
 {'model': 'SX-750',   'colour': 'White',  'horsepower': 180,  'fuel_capacity': 80}]`
"""

# input 1
existing_vehicles = [
    {'model': 'TX-130', 'colour': 'Green', 'horsepower': 150, 'fuel_capacity': 60},
    {'model': 'RX-850', 'colour': 'Red', 'horsepower': 120, 'fuel_capacity': 45}
]

new_vehicle =  ('SX-750', 'White', 180, 80)
add_vehicle(existing_vehicles, new_vehicle)

"""<br>

**Input 2:**

Expected output:

`[{'model': 'TX-130',  'colour': 'Green',  'horsepower': 150,  'fuel_capacity': 60},
 {'model': 'RX-850', 'colour': 'Red', 'horsepower': 120, 'fuel_capacity': 45},
 {'model': 'ZX-500', 'colour': 'Blue', 'horsepower': 130, 'fuel_capacity': 55}]`
"""

# input 2
existing_vehicles = [
    {'model': 'TX-130', 'colour': 'Green', 'horsepower': 150, 'fuel_capacity': 60},
    {'model': 'RX-850', 'colour': 'Red', 'horsepower': 120, 'fuel_capacity': 45}
]

new_vehicle_params = ('ZX-500', 'Blue', 130, 55)
add_vehicle(existing_vehicles, new_vehicle_params)

"""#  

<div align="center" style=" font-size: 80%; text-align: center; margin: 0 auto">
<img src="https://raw.githubusercontent.com/Explore-AI/Pictures/master/ExploreAI_logos/EAI_Blue_Dark.png"  style="width:200px";/>
</div>
"""